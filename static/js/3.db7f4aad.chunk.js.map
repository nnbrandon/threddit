{"version":3,"sources":["../node_modules/smoothscroll-anchor-polyfill/dist/index.mjs"],"names":["pendingFocusChange","isBrowser","window","w","d","document","docEl","documentElement","mockEl","createElement","hasNativeSupport","getAnchor","el","test","tagName","isAnchor","anchor","href","pathname","hostname","location","search","targetsLocalElement","parentElement","getScrollTarget","hash","decodeURIComponent","_unused","target","getElementById","slice","body","focusElement","focusOptions","preventScroll","focus","activeElement","prevTabIndex","getAttribute","setAttribute","getComputedStyle","outlineStyle","prevOutline","style","addEventListener","undoOutlineChange","removeAttribute","removeEventListener","supportsPreventScroll","preppedFocusOption","Object","defineProperty","get","_unused2","triggerSmoothscroll","clearTimeout","scroll","top","left","behavior","scrollIntoView","block","setTimeout","bind","shouldSmoothscroll","extractValue","docElStyle","valuesToCheck","scrollBehavior","exec","getPropertyValue","fontFamily","i","length","value","trim","defaultExport","polyfill","destroy","opts","globalFlag","__forceSmoothscrollAnchorPolyfill__","force","handleClick","trackScrollPositions","handleHashChange","evt","notPrimaryClick","metaKey","ctrlKey","shiftKey","button","defaultPrevented","preventDefault","history","pushState","title","lastTwoScrollPos","getScrollTop","scrollTop","currentPos"],"mappings":"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","file":"static/js/3.db7f4aad.chunk.js","sourcesContent":["/** @license MIT smoothscroll-anchor-polyfill@1.3.4 (c) 2021 Jonas Kuske */\n// @ts-check\n\n/**\n * @typedef {Object} GlobalFlag\n * @prop {boolean} [__forceSmoothscrollAnchorPolyfill__]\n * **DEPRECATED**: use `polyfill({ force: boolean })`\n *\n * @typedef {typeof globalThis & Window & GlobalFlag} WindowWithFlag\n */\n\n/***/\nconst isBrowser = typeof window !== 'undefined';\nconst w = isBrowser &&\n/** @type {WindowWithFlag} */\nwindow;\nconst d = isBrowser && document;\nconst docEl = isBrowser && d.documentElement;\nconst mockEl = isBrowser && d.createElement('a');\n\nconst hasNativeSupport = () => isBrowser && 'scrollBehavior' in mockEl;\n/**\n * @param {HTMLElement} el\n * @returns {el is HTMLAnchorElement}\n */\n\n\nconst isAnchor = el => /^a$/i.test(el.tagName);\n/**\n * Check if an element is an anchor pointing to a target on the current page\n * @param {HTMLAnchorElement} anchor\n */\n\n\nconst targetsLocalElement = anchor => {\n  // False if element isn't \"a\" or href has no #fragment\n  if (!/#/.test(anchor.href)) return false; // Fix bug in IE9 where anchor.pathname misses leading slash\n\n  let pathname =\n  /** @type {HTMLAnchorElement} */\n  anchor.pathname;\n  if (pathname[0] !== '/') pathname = '/' + pathname; // False if target isn't current page\n\n  if (anchor.hostname !== location.hostname || pathname !== location.pathname) return false; // False if anchor targets a ?query that is different from the current one\n  // e.g. /?page=1 → /?page=2#content\n\n  if (anchor.search && anchor.search !== location.search) return false;\n  return true;\n};\n/**\n * @param {HTMLElement} el\n * @returns {?HTMLAnchorElement} The found element or null\n */\n\n\nconst getAnchor = el => {\n  if (isAnchor(el) && targetsLocalElement(el)) return el;\n  return el.parentElement ? getAnchor(el.parentElement) : null;\n};\n/**\n * Returns the element whose id matches the hash or\n * document.body if the hash is \"#top\" or \"\" (empty string)\n * @param {string} hash\n */\n\n\nconst getScrollTarget = hash => {\n  if (typeof hash !== 'string') return null;\n\n  try {\n    hash = decodeURIComponent(hash); // \"#%F0%9F%91%8D%F0%9F%8F%BB\" -> \"#👍🏻\"\n  } catch (_unused) {} // Retrieve target if an id is specified in the hash, otherwise use body.\n  // If hash is \"#top\" and no target with id \"top\" was found, also use body\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-href\n\n\n  let target = hash ? d.getElementById(hash.slice(1)) : d.body;\n  if (hash === '#top' && !target) target = d.body;\n  return target;\n};\n/**\n * Focuses an element, if it's not focused after the first try,\n * allow focusing by adjusting tabIndex and retry\n * @param {HTMLElement} el\n */\n\n\nconst focusElement = el => {\n  const focusOptions = {\n    preventScroll: true\n  };\n  el.focus(focusOptions);\n\n  if (d.activeElement !== el) {\n    const prevTabIndex = el.getAttribute('tabindex');\n    el.setAttribute('tabindex', '-1');\n\n    if (getComputedStyle(el).outlineStyle === 'none') {\n      const prevOutline = el.style.outlineStyle;\n      el.style.outlineStyle = 'none';\n      el.addEventListener('blur', function undoOutlineChange() {\n        el.style.outlineStyle = prevOutline || '';\n        prevTabIndex != null ? el.setAttribute('tabindex', prevTabIndex) : el.removeAttribute('tabindex');\n        el.removeEventListener('blur', undoOutlineChange);\n      });\n    }\n\n    el.focus(focusOptions);\n  }\n}; // Stores the setTimeout id of pending focus changes, allows aborting them\n\n\nlet pendingFocusChange; // Check if browser supports focus without automatic scrolling (preventScroll)\n\nlet supportsPreventScroll = false;\n\nif (isBrowser) {\n  try {\n    // Define getter for preventScroll to find out if the browser accesses it\n    const preppedFocusOption = Object.defineProperty({}, 'preventScroll', {\n      // eslint-disable-next-line getter-return\n      get() {\n        supportsPreventScroll = true;\n      }\n\n    }); // Trigger focus – if browser uses preventScroll the const will be set to true\n\n    mockEl.focus(preppedFocusOption);\n  } catch (_unused2) {}\n}\n/**\n * Scrolls to a given element or to the top if the given element\n * is document.body, then focuses the element\n * @param {HTMLElement} target\n */\n\n\nconst triggerSmoothscroll = target => {\n  // Clear potential pending focus change triggered by a previous scroll\n  if (!supportsPreventScroll) clearTimeout(pendingFocusChange); // Use JS scroll APIs to scroll to top (if target is body) or to the element\n  // This allows polyfills for these APIs to do their smooth scrolling magic\n\n  const scrollTop = target === d.body;\n  if (scrollTop) w.scroll({\n    top: 0,\n    left: 0,\n    behavior: 'smooth'\n  });else target.scrollIntoView({\n    behavior: 'smooth',\n    block: 'start'\n  }); // If the browser supports preventScroll: immediately focus the target\n  // Otherwise schedule the focus so the smoothscroll isn't interrupted\n\n  if (supportsPreventScroll) focusElement(target);else pendingFocusChange = setTimeout(focusElement.bind(null, target), 450);\n};\n/**\n * Returns true if scroll-behavior: smooth is set and not overwritten\n * by a higher-specifity declaration, else returns false\n */\n\n\nconst shouldSmoothscroll = () => {\n  // Regex to extract the value following the scroll-behavior property name\n  const extractValue = /scroll-behavior:[\\s]*([^;\"']+)/;\n  const docElStyle = getComputedStyle(docEl); // Values to check for set scroll-behavior in order of priority/specificity\n\n  const valuesToCheck = [// Priority 1: behavior assigned to style property\n  // Allows toggling smoothscroll from JS (docEl.style.scrollBehavior = ...)\n  docEl.style.scrollBehavior, // Priority 2: behavior specified inline in style attribute\n  (extractValue.exec(docEl.getAttribute('style')) || [])[1], // Priority 3: custom property\n  // Behaves like regular CSS, e.g. allows using media queries\n  docElStyle.getPropertyValue('--scroll-behavior'), // Priority 4: behavior specified in fontFamily\n  // Same use case as priority 3, but supports legacy browsers without CSS vars\n  (extractValue.exec(docElStyle.fontFamily) || [])[1]]; // Loop over values in specified order, return once a valid value is found\n\n  for (var i = 0; i < valuesToCheck.length; i++) {\n    const value = valuesToCheck[i] && valuesToCheck[i].trim();\n    if (/^smooth$/.test(value)) return true;\n    if (/^(initial|inherit|auto|unset)$/.test(value)) return false;\n  } // No value found? Return false, no set value = no smoothscroll :(\n\n\n  return false;\n}; // @ts-check\n\n\nconst defaultExport = {\n  polyfill,\n  destroy\n};\n/**\r\n * Starts the polyfill by attaching the neccessary EventListeners\r\n *\r\n * Bails out if scrollBehavior is natively supported and the force flag\r\n * isn't set on the options argument or globally on window\r\n * @param {PolyfillOptions} [opts] Options for invoking the polyfill\r\n *\r\n * @typedef {Object} PolyfillOptions\r\n * @prop {boolean} [force] Enable despite native support, overrides global flag\r\n */\n\nfunction polyfill(opts = {}) {\n  destroy(); // Remove previous listeners\n\n  if (isBrowser) {\n    const globalFlag = w.__forceSmoothscrollAnchorPolyfill__;\n    const force = typeof opts.force === 'boolean' ? opts.force : globalFlag; // Abort if smoothscroll has native support and force flag isn't set\n\n    if (hasNativeSupport() && !force) return;\n    d.addEventListener('click', handleClick, false);\n    d.addEventListener('scroll', trackScrollPositions);\n    w.addEventListener('hashchange', handleHashChange);\n  }\n\n  return defaultExport;\n}\n/** Stops the polyfill by removing all EventListeners */\n\n\nfunction destroy() {\n  if (isBrowser) {\n    d.removeEventListener('click', handleClick, false);\n    d.removeEventListener('scroll', trackScrollPositions);\n    w.removeEventListener('hashchange', handleHashChange);\n  }\n\n  return defaultExport;\n}\n/**\r\n * Checks if the clicked target is an anchor pointing to a local element.\r\n * If so, prevents default behavior and handles the scroll using the\r\n * native JavaScript scroll APIs so smoothscroll-polyfill applies\r\n * @param {MouseEvent} evt\r\n */\n\n\nfunction handleClick(evt) {\n  const notPrimaryClick = evt.metaKey || evt.ctrlKey || evt.shiftKey || evt.button !== 0;\n  if (evt.defaultPrevented || notPrimaryClick) return; // scroll-behavior not set to smooth? Bail out, let browser handle it\n\n  if (!shouldSmoothscroll()) return; // Check the DOM from the click target upwards if a local anchor was clicked\n\n  const anchor = getAnchor(\n  /** @type {HTMLElement} */\n  evt.target);\n  if (!anchor) return; // Find the element targeted by the hash\n\n  const target = getScrollTarget(anchor.hash);\n\n  if (target) {\n    // Prevent default browser behavior to avoid a jump to the anchor target\n    evt.preventDefault(); // Trigger the smooth scroll\n\n    triggerSmoothscroll(target); // Append the hash to the URL\n\n    if (history.pushState) history.pushState(null, d.title, anchor.href);\n  }\n} // To enable smooth scrolling on hashchange, we need to immediately restore\n// the scroll pos after a hashchange changed it, so we track it constantly.\n// Some browsers don't trigger a scroll event before the hashchange,\n// so to undo, the position from last scroll is the one we need to go back to.\n// In others (e.g. IE) the scroll listener is triggered again before the\n// hashchange occurs and the last reported position is already the new one\n// updated by the hashchange – we need the second last to undo there.\n// Because of this we don't track just the last, but the last two positions.\n\n\nconst lastTwoScrollPos = [];\n/** Returns the scroll offset towards the top */\n\nconst getScrollTop = () => docEl.scrollTop || d.body.scrollTop;\n/**\r\n * Tries to undo the automatic, instant scroll caused by a hashchange\r\n * and instead scrolls smoothly to the new hash target\r\n */\n\n\nfunction handleHashChange() {\n  // scroll-behavior not set to smooth or body not parsed yet? Abort\n  if (!d.body || !shouldSmoothscroll()) return;\n  const target = getScrollTarget(location.hash);\n  if (!target) return; // If the position last reported by the scroll listener is the same as the\n  // current one caused by a hashchange, go back to second last – else last\n\n  const currentPos = getScrollTop();\n  const top = lastTwoScrollPos[lastTwoScrollPos[1] === currentPos ? 0 : 1]; // @ts-ignore\n  // Undo the scroll caused by the hashchange...\n  // Using {behavior: 'instant'} even though it's not in the spec anymore as\n  // Blink & Gecko support it – once an engine with native support doesn't,\n  // we need to disable scroll-behavior during scroll reset, then restore\n\n  w.scroll({\n    top,\n    behavior: 'instant'\n  }); // ...and instead smoothscroll to the target\n\n  triggerSmoothscroll(target);\n}\n/** Update the last two scroll positions */\n\n\nfunction trackScrollPositions() {\n  if (!d.body) return; // Body not parsed yet? Abort\n\n  lastTwoScrollPos[0] = lastTwoScrollPos[1];\n  lastTwoScrollPos[1] = getScrollTop();\n}\n\npolyfill();\nexport { defaultExport as default, destroy, polyfill };\n"],"sourceRoot":""}